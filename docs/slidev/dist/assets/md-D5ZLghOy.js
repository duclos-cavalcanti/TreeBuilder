import{_ as l}from"./TUMLogo.vue_vue_type_script_setup_true_lang-C6fhutID.js";import{o as m,c as P,k as p,e as o,l as s,g as e,q as _,s as c,A as r}from"./modules/vue-DaYSqhD_.js";import{I as u}from"./slidev/two-cols-header-B39fTfYE.js";import{u as f,f as d}from"./slidev/context-Cz62jeIy.js";import"./index-D_pCmMBL.js";import"./modules/shiki-DLxQYbt2.js";const N="/assets/FAQ-D9-610Dw.png",x={__name:"LemonDrop.md__slidev_3",setup(T){const{$slidev:O,$nav:g,$clicksContext:i,$clicks:D,$page:A,$renderContext:I,$frontmatter:n}=f();return i.setup(),(L,t)=>{const a=l;return m(),P(u,_(c(r(d)(r(n),2))),{default:p(()=>[t[0]||(t[0]=o("h1",null,"State-of-the-Art: LemonDrop",-1)),t[1]||(t[1]=o("ul",null,[o("li",null,"Method of Selecting/Scheduling VMs on a cluster"),o("li",null,"NP-Hard")],-1)),t[2]||(t[2]=o("p",null,[o("img",{alt:"Heuristic",style:{transform:"translate(-50%, -50%) scale(0.7)"},src:N,class:"absolute top-60% left-50%"})],-1)),s(a,{variant:"white"}),e(" --- "),e(" layout: two-cols-header "),e(" --- "),e(""),e(" # State-of-the-Art: LemonDrop "),e(" - Λ = LOAD_MATRIX: LOAD "),e(" - Δ = OWD_MATRIX:  OWD "),e(" - Min(trace(Λ * P * Δ_T * P_T )) "),e(""),e(" <div  "),e('     alt="sequenceDiagram" '),e('     style="transform: scale(0.8)" '),e('     class="absolute top-5% left-30%" '),e(" > "),e(""),e(" ```py  "),e(" # i=0, s=0, P(0) = 11T, a doubly stochastic matrix, i: iteration, s: stopping condition "),e(" P = np.ones((self.N, self.N)) / self.N "),e(" while s == 0: "),e("     # ∇f(P(i)) = - Λ P(i) Δ_T - Λ_T P(i) Δ "),e("     grad = - (LOAD @ P @ OWD.T) - (LOAD.T @ P @ OWD) "),e("     # Q(i) = argmin_{P ∈ D} trace(∇f(P(i))_T P) , Hungarian Algorithm / LAP "),e("     Q = np.zeros((self.N, self.N)) "),e("     row, col = optimize.linear_sum_assignment(-grad) "),e("     Q[row, col] = 1 "),e("     # BEST STEP SIZE IN CHOSEN DIRECTION: α(i) = min_{α ∈ [0,1]} f(P(i) + α * Q(i)) "),e("     result = optimize.minimize_scalar( "),e("                 lambda alpha: np.trace(LOAD @ (P + alpha * Q) @ OWD.T @ (P + alpha * Q).T),  "),e("                 bounds=(0, 1),  "),e("                 method='bounded' "),e("     ) "),e("     alpha = result.x "),e("     # UPDATE OUR CURRENT SOLUTION: P(i+1) = P(i) + alpha * Q(i) "),e("     P_NEXT  = P + (alpha * Q) "),e("     # STOPPING CONDITIONS "),e("     if np.linalg.norm(P_NEXT - P, ord='fro') < epsilon: "),e("         converged = True "),e("         s = 1 "),e("     if i >= max_i: "),e("         s = 1 "),e("     P = P_NEXT "),e("     i += 1 "),e(" # PROJECTION OF P ONTO P[FINAL]: # P(FINAL) = argmin_{P ∈ P} || P(i-1)P_T ||_F "),e(" P_FINAL = np.zeros((self.N, self.N)) "),e(" row, col = optimize.linear_sum_assignment(-P)  "),e(" P_FINAL[row, col] = 1 "),e(" return P_FINAL, converged, (time.time() - start) "),e(" ``` "),e(" </div> "),s(a,{variant:"white"})]),_:1},16)}}};export{x as default};
